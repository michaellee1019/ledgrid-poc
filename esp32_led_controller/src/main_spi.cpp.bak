// ESP32-S3 SPI Slave LED Controller with Hardware DMA
// Optimized for Seeed XIAO ESP32-S3
// Using FastLED for best performance with 3.3V logic

#include <Arduino.h>
#include <FastLED.h>
#include "driver/spi_slave.h"
#include "driver/gpio.h"

// ============================================
// SPI Configuration (using available XIAO pins)
// ============================================
#define SPI_MOSI_PIN  GPIO_NUM_9   // D10 on XIAO
#define SPI_MISO_PIN  GPIO_NUM_8   // D9 on XIAO (optional)
#define SPI_SCK_PIN   GPIO_NUM_7   // D8 on XIAO
#define SPI_CS_PIN    GPIO_NUM_2   // D1 on XIAO

// ============================================
// LED Configuration
// ============================================
#define LED_PIN       5            // GPIO5 = D4 on XIAO
#define NUM_STRIPS    8            // Number of strips (virtual for single pin)
#define NUM_LED_PER_STRIP 20       // LEDs per strip
#define TOTAL_LEDS    (NUM_STRIPS * NUM_LED_PER_STRIP)  // 160 LEDs

CRGB leds[TOTAL_LEDS];

// ============================================
// SPI DMA Buffer
// ============================================
#define DMA_BUFFER_SIZE 1024
WORD_ALIGNED_ATTR uint8_t spi_rx_buffer[DMA_BUFFER_SIZE];
WORD_ALIGNED_ATTR uint8_t spi_tx_buffer[DMA_BUFFER_SIZE];  // Dummy TX buffer

// ============================================
// Command Protocol
// ============================================
#define CMD_SET_PIXEL       0x01
#define CMD_SET_BRIGHTNESS  0x02
#define CMD_SHOW            0x03
#define CMD_CLEAR           0x04
#define CMD_SET_RANGE       0x05
#define CMD_SET_ALL_PIXELS  0x06
#define CMD_PING            0xFF

// Statistics
volatile uint32_t packets_received = 0;
volatile uint32_t frames_rendered = 0;
uint8_t global_brightness = 50;  // 0-255

// ============================================
// SPI Transaction Callback
// ============================================
void IRAM_ATTR spi_post_trans_callback(spi_slave_transaction_t *trans) {
  packets_received++;
}

// ============================================
// Process received SPI command
// ============================================
void processCommand(uint8_t* buffer, size_t len) {
  if (len == 0) return;
  
  uint8_t cmd = buffer[0];
  
  switch (cmd) {
    case CMD_PING:
      Serial.println("ðŸ“¥ PING");
      break;
    
    case CMD_SET_PIXEL:
      if (len >= 6) {
        uint16_t pixel = (buffer[1] << 8) | buffer[2];
        uint8_t r = buffer[3];
        uint8_t g = buffer[4];
        uint8_t b = buffer[5];
        
        if (pixel < TOTAL_LEDS) {
          leds[pixel] = CRGB(r, g, b);
        }
      }
      break;
    
    case CMD_SET_BRIGHTNESS:
      if (len >= 2) {
        global_brightness = buffer[1];
        FastLED.setBrightness(global_brightness);
        Serial.printf("ðŸ“¥ Brightness: %d\n", global_brightness);
      }
      break;
    
    case CMD_SHOW:
      FastLED.show();
      frames_rendered++;
      Serial.println("ðŸ“¥ SHOW");
      break;
    
    case CMD_CLEAR:
      FastLED.clear();
      FastLED.show();
      frames_rendered++;
      Serial.println("ðŸ“¥ CLEAR");
      break;
    
    case CMD_SET_RANGE:
      if (len >= 4) {
        uint16_t start = (buffer[1] << 8) | buffer[2];
        uint8_t count = buffer[3];
        uint16_t expected_len = 4 + (count * 3);
        
        if (len >= expected_len) {
          for (uint8_t i = 0; i < count; i++) {
            uint16_t pixel = start + i;
            if (pixel < TOTAL_LEDS) {
              uint8_t r = buffer[4 + (i * 3)];
              uint8_t g = buffer[4 + (i * 3) + 1];
              uint8_t b = buffer[4 + (i * 3) + 2];
              leds[pixel] = CRGB(r, g, b);
            }
          }
          Serial.printf("ðŸ“¥ SET_RANGE: %d LEDs from %d\n", count, start);
        }
      }
      break;
    
    case CMD_SET_ALL_PIXELS: {
      uint16_t expected_len = 1 + (TOTAL_LEDS * 3);  // 481 bytes
      
      if (len >= expected_len) {
        for (uint16_t i = 0; i < TOTAL_LEDS; i++) {
          uint8_t r = buffer[1 + (i * 3)];
          uint8_t g = buffer[1 + (i * 3) + 1];
          uint8_t b = buffer[1 + (i * 3) + 2];
          leds[i] = CRGB(r, g, b);
        }
        Serial.printf("ðŸ“¥ SET_ALL: %d LEDs\n", TOTAL_LEDS);
      } else {
        Serial.printf("âš ï¸ SET_ALL: Expected %d bytes, got %d\n", expected_len, len);
      }
      break;
    }
    
    default:
      Serial.printf("âš ï¸ Unknown command: 0x%02X\n", cmd);
      break;
  }
}

// ============================================
// Setup
// ============================================
void setup() {
  Serial.begin(115200);
  
  // Wait for USB CDC to be ready
  delay(2000);
  while (!Serial && millis() < 5000) {
    delay(100);
  }
  
  Serial.println("\n\n========================================");
  Serial.println("ðŸš€ ESP32-S3 SPI Slave LED Controller");
  Serial.println("   Hardware SPI + DMA");
  Serial.println("========================================");
  Serial.printf("Board: Seeed XIAO ESP32-S3\n");
  Serial.printf("Total LEDs: %d\n", TOTAL_LEDS);
  Serial.printf("SPI Speed: Mode 3, Hardware DMA\n");
  Serial.println("========================================\n");
  
  // ============================================
  // Initialize FastLED
  // ============================================
  Serial.println("Initializing FastLED...");
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, TOTAL_LEDS);
  FastLED.setBrightness(global_brightness);
  FastLED.clear();
  FastLED.show();
  Serial.println("  âœ“ FastLED initialized");
  
  // Test flash
  Serial.println("Test flash...");
  fill_solid(leds, TOTAL_LEDS, CRGB::White);
  FastLED.show();
  delay(200);
  FastLED.clear();
  FastLED.show();
  
  // ============================================
  // Configure SPI Slave with DMA
  // ============================================
  Serial.println("\nConfiguring SPI slave...");
  
  spi_bus_config_t bus_config = {
    .mosi_io_num = SPI_MOSI_PIN,
    .miso_io_num = SPI_MISO_PIN,
    .sclk_io_num = SPI_SCK_PIN,
    .quadwp_io_num = -1,
    .quadhd_io_num = -1,
    .max_transfer_sz = DMA_BUFFER_SIZE,
  };
  
  spi_slave_interface_config_t slave_config = {
    .spics_io_num = SPI_CS_PIN,
    .flags = 0,
    .queue_size = 3,
    .mode = 3,  // SPI Mode 3 (CPOL=1, CPHA=1) - most reliable
    .post_setup_cb = NULL,
    .post_trans_cb = spi_post_trans_callback,
  };
  
  // Initialize SPI slave
  esp_err_t ret = spi_slave_initialize(SPI2_HOST, &bus_config, &slave_config, SPI_DMA_CH_AUTO);
  
  if (ret != ESP_OK) {
    Serial.printf("  âœ— SPI slave init failed: %d\n", ret);
    while (1) delay(1000);
  }
  
  Serial.println("  âœ“ SPI slave configured");
  Serial.printf("    MOSI: GPIO%d\n", SPI_MOSI_PIN);
  Serial.printf("    MISO: GPIO%d\n", SPI_MISO_PIN);
  Serial.printf("    SCK:  GPIO%d\n", SPI_SCK_PIN);
  Serial.printf("    CS:   GPIO%d\n", SPI_CS_PIN);
  Serial.printf("    Mode: 3 (CPOL=1, CPHA=1)\n");
  Serial.printf("    DMA:  Enabled (buffer: %d bytes)\n", DMA_BUFFER_SIZE);
  
  Serial.println("\n========================================");
  Serial.println("Wiring:");
  Serial.println("  RPi GPIO 10 (MOSI) â†’ XIAO GPIO9 (D10)");
  Serial.println("  RPi GPIO 11 (SCLK) â†’ XIAO GPIO7 (D8)");
  Serial.println("  RPi GPIO 8  (CE0)  â†’ XIAO GPIO2 (D1)");
  Serial.println("  RPi GND â†’ XIAO GND");
  Serial.println("  NeoPixels Data â†’ XIAO GPIO5 (D4)");
  Serial.println("========================================\n");
  
  Serial.println("*** Ready for SPI commands! ***\n");
}

// ============================================
// Main Loop
// ============================================
void loop() {
  // Prepare SPI transaction
  memset(spi_rx_buffer, 0, DMA_BUFFER_SIZE);
  memset(spi_tx_buffer, 0, DMA_BUFFER_SIZE);
  
  spi_slave_transaction_t transaction = {
    .length = DMA_BUFFER_SIZE * 8,  // Length in bits
    .trans_len = 0,                  // Actual received length (filled by driver)
    .tx_buffer = spi_tx_buffer,
    .rx_buffer = spi_rx_buffer,
  };
  
  // Wait for SPI transaction with 100ms timeout
  esp_err_t ret = spi_slave_transmit(SPI2_HOST, &transaction, pdMS_TO_TICKS(100));
  
  if (ret == ESP_OK && transaction.trans_len > 0) {
    size_t bytes_received = transaction.trans_len / 8;
    Serial.printf("ðŸ“¥ Received %d bytes | First byte: 0x%02X\n", bytes_received, spi_rx_buffer[0]);
    
    // Show first 8 bytes for debugging
    Serial.print("   Data: ");
    for (int i = 0; i < min((int)bytes_received, 8); i++) {
      Serial.printf("0x%02X ", spi_rx_buffer[i]);
    }
    Serial.println();
    
    // Process the received command
    processCommand(spi_rx_buffer, bytes_received);
  } else if (ret != ESP_ERR_TIMEOUT) {
    // Print errors except timeout (timeout is normal when waiting)
    Serial.printf("âš ï¸ SPI error: %d\n", ret);
  }
  
  // Print stats every 5 seconds
  static uint32_t last_stats = 0;
  if (millis() - last_stats > 5000) {
    Serial.printf("ðŸ“Š Waiting for SPI... | Packets: %u | Frames: %u | Heap: %u\n", 
                  packets_received, frames_rendered, ESP.getFreeHeap());
    last_stats = millis();
  }
}

